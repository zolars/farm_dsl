/*
 * generated by Xtext 2.26.0
 */
package uk.ac.kcl.farm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.farm.farm.Attribute;
import uk.ac.kcl.farm.farm.BoolLiteral;
import uk.ac.kcl.farm.farm.ConditionAndExpression;
import uk.ac.kcl.farm.farm.ConditionOrExpression;
import uk.ac.kcl.farm.farm.CountStageFunction;
import uk.ac.kcl.farm.farm.Crop;
import uk.ac.kcl.farm.farm.CropAttributes;
import uk.ac.kcl.farm.farm.CropStage;
import uk.ac.kcl.farm.farm.CropStages;
import uk.ac.kcl.farm.farm.Divide;
import uk.ac.kcl.farm.farm.ElseJudgeStatement;
import uk.ac.kcl.farm.farm.ElseStatement;
import uk.ac.kcl.farm.farm.Equal;
import uk.ac.kcl.farm.farm.ExecuteStatement;
import uk.ac.kcl.farm.farm.Expression;
import uk.ac.kcl.farm.farm.FarmPackage;
import uk.ac.kcl.farm.farm.FarmProgram;
import uk.ac.kcl.farm.farm.Field;
import uk.ac.kcl.farm.farm.FieldMonitor;
import uk.ac.kcl.farm.farm.GetValueFunction;
import uk.ac.kcl.farm.farm.GreaterThan;
import uk.ac.kcl.farm.farm.GreaterThanOrEqual;
import uk.ac.kcl.farm.farm.JudgeStatement;
import uk.ac.kcl.farm.farm.LessThan;
import uk.ac.kcl.farm.farm.LessThanOrEqual;
import uk.ac.kcl.farm.farm.LoopStatement;
import uk.ac.kcl.farm.farm.Minus;
import uk.ac.kcl.farm.farm.Mission;
import uk.ac.kcl.farm.farm.MoveFunction;
import uk.ac.kcl.farm.farm.Multiply;
import uk.ac.kcl.farm.farm.NotEqual;
import uk.ac.kcl.farm.farm.Param;
import uk.ac.kcl.farm.farm.PlantFunction;
import uk.ac.kcl.farm.farm.Plus;
import uk.ac.kcl.farm.farm.RealLiteral;
import uk.ac.kcl.farm.farm.ReportFunction;
import uk.ac.kcl.farm.farm.ReturnStatement;
import uk.ac.kcl.farm.farm.SetFieldValueFunction;
import uk.ac.kcl.farm.farm.TaskStatement;
import uk.ac.kcl.farm.farm.UnaryExpression;
import uk.ac.kcl.farm.farm.Variable;
import uk.ac.kcl.farm.farm.WaitFunction;
import uk.ac.kcl.farm.services.FarmGrammarAccess;

@SuppressWarnings("all")
public class FarmSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FarmGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FarmPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FarmPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case FarmPackage.BOOL_LITERAL:
				sequence_BooleanLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case FarmPackage.CONDITION_AND_EXPRESSION:
				sequence_ConditionAndExpression(context, (ConditionAndExpression) semanticObject); 
				return; 
			case FarmPackage.CONDITION_OR_EXPRESSION:
				sequence_ConditionOrExpression(context, (ConditionOrExpression) semanticObject); 
				return; 
			case FarmPackage.COUNT_STAGE_FUNCTION:
				sequence_CountStageFunction(context, (CountStageFunction) semanticObject); 
				return; 
			case FarmPackage.CROP:
				sequence_Crop(context, (Crop) semanticObject); 
				return; 
			case FarmPackage.CROP_ATTRIBUTES:
				sequence_CropAttributes(context, (CropAttributes) semanticObject); 
				return; 
			case FarmPackage.CROP_STAGE:
				sequence_CropStage(context, (CropStage) semanticObject); 
				return; 
			case FarmPackage.CROP_STAGES:
				sequence_CropStages(context, (CropStages) semanticObject); 
				return; 
			case FarmPackage.DIVIDE:
				sequence_MultiplicationExpression(context, (Divide) semanticObject); 
				return; 
			case FarmPackage.ELSE_JUDGE_STATEMENT:
				sequence_ElseJudgeStatement(context, (ElseJudgeStatement) semanticObject); 
				return; 
			case FarmPackage.ELSE_STATEMENT:
				sequence_ElseStatement(context, (ElseStatement) semanticObject); 
				return; 
			case FarmPackage.EQUAL:
				sequence_RelationOrExpression(context, (Equal) semanticObject); 
				return; 
			case FarmPackage.EXECUTE_STATEMENT:
				sequence_ExecuteStatement(context, (ExecuteStatement) semanticObject); 
				return; 
			case FarmPackage.EXPRESSION:
				if (rule == grammarAccess.getNotBooleanExpressionRule()) {
					sequence_NotBooleanExpression(context, (Expression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getConditionOrExpressionRule()
						|| action == grammarAccess.getConditionOrExpressionAccess().getConditionOrExpressionLeftAction_1_0_0()
						|| rule == grammarAccess.getConditionAndExpressionRule()
						|| action == grammarAccess.getConditionAndExpressionAccess().getConditionAndExpressionLeftAction_1_0_0()
						|| rule == grammarAccess.getRelationOrExpressionRule()
						|| action == grammarAccess.getRelationOrExpressionAccess().getLessThanOrEqualLeftAction_1_0_0_0_0()
						|| action == grammarAccess.getRelationOrExpressionAccess().getLessThanLeftAction_1_0_0_1_0()
						|| action == grammarAccess.getRelationOrExpressionAccess().getGreaterThanOrEqualLeftAction_1_0_0_2_0()
						|| action == grammarAccess.getRelationOrExpressionAccess().getGreaterThanLeftAction_1_0_0_3_0()
						|| action == grammarAccess.getRelationOrExpressionAccess().getEqualLeftAction_1_0_0_4_0()
						|| action == grammarAccess.getRelationOrExpressionAccess().getNotEqualLeftAction_1_0_0_5_0()
						|| rule == grammarAccess.getAdditionExpressionRule()
						|| action == grammarAccess.getAdditionExpressionAccess().getPlusLeftAction_1_0_0_0_0()
						|| action == grammarAccess.getAdditionExpressionAccess().getMinusLeftAction_1_0_0_1_0()
						|| rule == grammarAccess.getMultiplicationExpressionRule()
						|| action == grammarAccess.getMultiplicationExpressionAccess().getMultiplyLeftAction_1_0_0_0_0()
						|| action == grammarAccess.getMultiplicationExpressionAccess().getDivideLeftAction_1_0_0_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getUnaryExpressionNotPlusMinusRule()
						|| rule == grammarAccess.getPrimaryExpressionRule()) {
					sequence_NotBooleanExpression_PrimaryExpression(context, (Expression) semanticObject); 
					return; 
				}
				else break;
			case FarmPackage.FARM_PROGRAM:
				sequence_FarmProgram(context, (FarmProgram) semanticObject); 
				return; 
			case FarmPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case FarmPackage.FIELD_MONITOR:
				sequence_FieldMonitor(context, (FieldMonitor) semanticObject); 
				return; 
			case FarmPackage.GET_VALUE_FUNCTION:
				sequence_GetValueFunction(context, (GetValueFunction) semanticObject); 
				return; 
			case FarmPackage.GREATER_THAN:
				sequence_RelationOrExpression(context, (GreaterThan) semanticObject); 
				return; 
			case FarmPackage.GREATER_THAN_OR_EQUAL:
				sequence_RelationOrExpression(context, (GreaterThanOrEqual) semanticObject); 
				return; 
			case FarmPackage.JUDGE_STATEMENT:
				sequence_JudgeStatement(context, (JudgeStatement) semanticObject); 
				return; 
			case FarmPackage.LESS_THAN:
				sequence_RelationOrExpression(context, (LessThan) semanticObject); 
				return; 
			case FarmPackage.LESS_THAN_OR_EQUAL:
				sequence_RelationOrExpression(context, (LessThanOrEqual) semanticObject); 
				return; 
			case FarmPackage.LOOP_STATEMENT:
				sequence_LoopStatement(context, (LoopStatement) semanticObject); 
				return; 
			case FarmPackage.MINUS:
				sequence_AdditionExpression(context, (Minus) semanticObject); 
				return; 
			case FarmPackage.MISSION:
				sequence_Mission(context, (Mission) semanticObject); 
				return; 
			case FarmPackage.MOVE_FUNCTION:
				sequence_MoveFunction(context, (MoveFunction) semanticObject); 
				return; 
			case FarmPackage.MULTIPLY:
				sequence_MultiplicationExpression(context, (Multiply) semanticObject); 
				return; 
			case FarmPackage.NOT_EQUAL:
				sequence_RelationOrExpression(context, (NotEqual) semanticObject); 
				return; 
			case FarmPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case FarmPackage.PLANT_FUNCTION:
				sequence_PlantFunction(context, (PlantFunction) semanticObject); 
				return; 
			case FarmPackage.PLUS:
				sequence_AdditionExpression(context, (Plus) semanticObject); 
				return; 
			case FarmPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case FarmPackage.REPORT_FUNCTION:
				sequence_ReportFunction(context, (ReportFunction) semanticObject); 
				return; 
			case FarmPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case FarmPackage.SET_FIELD_VALUE_FUNCTION:
				sequence_SetFieldValueFunction(context, (SetFieldValueFunction) semanticObject); 
				return; 
			case FarmPackage.TASK_STATEMENT:
				sequence_TaskStatement(context, (TaskStatement) semanticObject); 
				return; 
			case FarmPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case FarmPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case FarmPackage.WAIT_FUNCTION:
				sequence_WaitFunction(context, (WaitFunction) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Minus
	 *     ConditionOrExpression returns Minus
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Minus
	 *     ConditionAndExpression returns Minus
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Minus
	 *     RelationOrExpression returns Minus
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Minus
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Minus
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Minus
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Minus
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Minus
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Minus
	 *     AdditionExpression returns Minus
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Minus
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Minus
	 *     MultiplicationExpression returns Minus
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Minus
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Minus
	 *     UnaryExpression returns Minus
	 *     UnaryExpressionNotPlusMinus returns Minus
	 *     PrimaryExpression returns Minus
	 *
	 * Constraint:
	 *     (left=AdditionExpression_Minus_1_0_0_1_0 right+=MultiplicationExpression)
	 * </pre>
	 */
	protected void sequence_AdditionExpression(ISerializationContext context, Minus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Plus
	 *     ConditionOrExpression returns Plus
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Plus
	 *     ConditionAndExpression returns Plus
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Plus
	 *     RelationOrExpression returns Plus
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Plus
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Plus
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Plus
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Plus
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Plus
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Plus
	 *     AdditionExpression returns Plus
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Plus
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Plus
	 *     MultiplicationExpression returns Plus
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Plus
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Plus
	 *     UnaryExpression returns Plus
	 *     UnaryExpressionNotPlusMinus returns Plus
	 *     PrimaryExpression returns Plus
	 *
	 * Constraint:
	 *     (left=AdditionExpression_Plus_1_0_0_0_0 right+=MultiplicationExpression)
	 * </pre>
	 */
	protected void sequence_AdditionExpression(ISerializationContext context, Plus semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.ATTRIBUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns BoolLiteral
	 *     ConditionOrExpression returns BoolLiteral
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns BoolLiteral
	 *     ConditionAndExpression returns BoolLiteral
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns BoolLiteral
	 *     RelationOrExpression returns BoolLiteral
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns BoolLiteral
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns BoolLiteral
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns BoolLiteral
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns BoolLiteral
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns BoolLiteral
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns BoolLiteral
	 *     AdditionExpression returns BoolLiteral
	 *     AdditionExpression.Plus_1_0_0_0_0 returns BoolLiteral
	 *     AdditionExpression.Minus_1_0_0_1_0 returns BoolLiteral
	 *     MultiplicationExpression returns BoolLiteral
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns BoolLiteral
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns BoolLiteral
	 *     UnaryExpression returns BoolLiteral
	 *     UnaryExpressionNotPlusMinus returns BoolLiteral
	 *     PrimaryExpression returns BoolLiteral
	 *     Literal returns BoolLiteral
	 *     BooleanLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     val=BOOLEAN
	 * </pre>
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.BOOL_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.BOOL_LITERAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralAccess().getValBOOLEANTerminalRuleCall_1_0(), semanticObject.isVal());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ConditionAndExpression
	 *     ConditionOrExpression returns ConditionAndExpression
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns ConditionAndExpression
	 *     ConditionAndExpression returns ConditionAndExpression
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns ConditionAndExpression
	 *     RelationOrExpression returns ConditionAndExpression
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns ConditionAndExpression
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns ConditionAndExpression
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns ConditionAndExpression
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns ConditionAndExpression
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns ConditionAndExpression
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns ConditionAndExpression
	 *     AdditionExpression returns ConditionAndExpression
	 *     AdditionExpression.Plus_1_0_0_0_0 returns ConditionAndExpression
	 *     AdditionExpression.Minus_1_0_0_1_0 returns ConditionAndExpression
	 *     MultiplicationExpression returns ConditionAndExpression
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns ConditionAndExpression
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns ConditionAndExpression
	 *     UnaryExpression returns ConditionAndExpression
	 *     UnaryExpressionNotPlusMinus returns ConditionAndExpression
	 *     PrimaryExpression returns ConditionAndExpression
	 *
	 * Constraint:
	 *     (left=ConditionAndExpression_ConditionAndExpression_1_0_0 right=RelationOrExpression)
	 * </pre>
	 */
	protected void sequence_ConditionAndExpression(ISerializationContext context, ConditionAndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CONDITION_AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CONDITION_AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CONDITION_AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CONDITION_AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAndExpressionAccess().getConditionAndExpressionLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionAndExpressionAccess().getRightRelationOrExpressionParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ConditionOrExpression
	 *     ConditionOrExpression returns ConditionOrExpression
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns ConditionOrExpression
	 *     ConditionAndExpression returns ConditionOrExpression
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns ConditionOrExpression
	 *     RelationOrExpression returns ConditionOrExpression
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns ConditionOrExpression
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns ConditionOrExpression
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns ConditionOrExpression
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns ConditionOrExpression
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns ConditionOrExpression
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns ConditionOrExpression
	 *     AdditionExpression returns ConditionOrExpression
	 *     AdditionExpression.Plus_1_0_0_0_0 returns ConditionOrExpression
	 *     AdditionExpression.Minus_1_0_0_1_0 returns ConditionOrExpression
	 *     MultiplicationExpression returns ConditionOrExpression
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns ConditionOrExpression
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns ConditionOrExpression
	 *     UnaryExpression returns ConditionOrExpression
	 *     UnaryExpressionNotPlusMinus returns ConditionOrExpression
	 *     PrimaryExpression returns ConditionOrExpression
	 *
	 * Constraint:
	 *     (left=ConditionOrExpression_ConditionOrExpression_1_0_0 right=ConditionAndExpression)
	 * </pre>
	 */
	protected void sequence_ConditionOrExpression(ISerializationContext context, ConditionOrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CONDITION_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CONDITION_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CONDITION_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CONDITION_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionOrExpressionAccess().getConditionOrExpressionLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionOrExpressionAccess().getRightConditionAndExpressionParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CountStageFunction
	 *     BuiltinFunction returns CountStageFunction
	 *     CountStageFunction returns CountStageFunction
	 *
	 * Constraint:
	 *     countStageCrop=[Crop|ID]
	 * </pre>
	 */
	protected void sequence_CountStageFunction(ISerializationContext context, CountStageFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.COUNT_STAGE_FUNCTION__COUNT_STAGE_CROP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.COUNT_STAGE_FUNCTION__COUNT_STAGE_CROP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountStageFunctionAccess().getCountStageCropCropIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.COUNT_STAGE_FUNCTION__COUNT_STAGE_CROP, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CropAttributes returns CropAttributes
	 *
	 * Constraint:
	 *     (type=[Attribute|ID] value=Expression)
	 * </pre>
	 */
	protected void sequence_CropAttributes(ISerializationContext context, CropAttributes semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__TYPE));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCropAttributesAccess().getTypeAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.CROP_ATTRIBUTES__TYPE, false));
		feeder.accept(grammarAccess.getCropAttributesAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CropStage returns CropStage
	 *
	 * Constraint:
	 *     (name=STRING timeConsumend=Expression elements+=CropAttributes*)
	 * </pre>
	 */
	protected void sequence_CropStage(ISerializationContext context, CropStage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CropStages returns CropStages
	 *
	 * Constraint:
	 *     (elements+=CropStage elements+=CropStage*)
	 * </pre>
	 */
	protected void sequence_CropStages(ISerializationContext context, CropStages semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns Crop
	 *     Crop returns Crop
	 *
	 * Constraint:
	 *     (name=ID cropName=STRING cropStages+=CropStages)
	 * </pre>
	 */
	protected void sequence_Crop(ISerializationContext context, Crop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElseJudgeStatement returns ElseJudgeStatement
	 *
	 * Constraint:
	 *     (condition=Expression elseJudgeStatements+=Statement*)
	 * </pre>
	 */
	protected void sequence_ElseJudgeStatement(ISerializationContext context, ElseJudgeStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElseStatement returns ElseStatement
	 *
	 * Constraint:
	 *     elseStatements+=Statement*
	 * </pre>
	 */
	protected void sequence_ElseStatement(ISerializationContext context, ElseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ExecuteStatement returns ExecuteStatement
	 *
	 * Constraint:
	 *     executeStatements+=Statement*
	 * </pre>
	 */
	protected void sequence_ExecuteStatement(ISerializationContext context, ExecuteStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FarmProgram returns FarmProgram
	 *
	 * Constraint:
	 *     (statements+=Crop | statements+=Field | statements+=Mission | statements+=Attribute)+
	 * </pre>
	 */
	protected void sequence_FarmProgram(ISerializationContext context, FarmProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FieldMonitor returns FieldMonitor
	 *
	 * Constraint:
	 *     monitor=[Attribute|ID]
	 * </pre>
	 */
	protected void sequence_FieldMonitor(ISerializationContext context, FieldMonitor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.FIELD_MONITOR__MONITOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.FIELD_MONITOR__MONITOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldMonitorAccess().getMonitorAttributeIDTerminalRuleCall_0_1(), semanticObject.eGet(FarmPackage.Literals.FIELD_MONITOR__MONITOR, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Entity returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         fieldName=STRING 
	 *         ip=IP 
	 *         (fieldType='inside' | fieldType='outside') 
	 *         (fieldLight='sunlight' | fieldLight='LED') 
	 *         fieldMonitors+=FieldMonitor 
	 *         fieldMonitors+=FieldMonitor*
	 *     )
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns GetValueFunction
	 *     BuiltinFunction returns GetValueFunction
	 *     GetValueFunction returns GetValueFunction
	 *
	 * Constraint:
	 *     (entity=[Entity|ID] attribute=STRING)
	 * </pre>
	 */
	protected void sequence_GetValueFunction(ISerializationContext context, GetValueFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GET_VALUE_FUNCTION__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GET_VALUE_FUNCTION__ENTITY));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GET_VALUE_FUNCTION__ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GET_VALUE_FUNCTION__ATTRIBUTE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGetValueFunctionAccess().getEntityEntityIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.GET_VALUE_FUNCTION__ENTITY, false));
		feeder.accept(grammarAccess.getGetValueFunctionAccess().getAttributeSTRINGTerminalRuleCall_2_0(), semanticObject.getAttribute());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns JudgeStatement
	 *     JudgeStatement returns JudgeStatement
	 *
	 * Constraint:
	 *     (condition=Expression judgeStatements+=Statement* elseJudgeStatements+=ElseJudgeStatement* elseStatements+=ElseStatement?)
	 * </pre>
	 */
	protected void sequence_JudgeStatement(ISerializationContext context, JudgeStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LoopStatement
	 *     LoopStatement returns LoopStatement
	 *
	 * Constraint:
	 *     (condition=Expression loopStatements+=Statement*)
	 * </pre>
	 */
	protected void sequence_LoopStatement(ISerializationContext context, LoopStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mission returns Mission
	 *
	 * Constraint:
	 *     (name=ID (missionStatements+=TaskStatement | missionStatements+=ExecuteStatement)+)
	 * </pre>
	 */
	protected void sequence_Mission(ISerializationContext context, Mission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns MoveFunction
	 *     BuiltinFunction returns MoveFunction
	 *     MoveFunction returns MoveFunction
	 *
	 * Constraint:
	 *     (moveFromField=[Field|ID] moveToField=[Field|ID])
	 * </pre>
	 */
	protected void sequence_MoveFunction(ISerializationContext context, MoveFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.MOVE_FUNCTION__MOVE_FROM_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.MOVE_FUNCTION__MOVE_FROM_FIELD));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.MOVE_FUNCTION__MOVE_TO_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.MOVE_FUNCTION__MOVE_TO_FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveFunctionAccess().getMoveFromFieldFieldIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FarmPackage.Literals.MOVE_FUNCTION__MOVE_FROM_FIELD, false));
		feeder.accept(grammarAccess.getMoveFunctionAccess().getMoveToFieldFieldIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FarmPackage.Literals.MOVE_FUNCTION__MOVE_TO_FIELD, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Divide
	 *     ConditionOrExpression returns Divide
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Divide
	 *     ConditionAndExpression returns Divide
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Divide
	 *     RelationOrExpression returns Divide
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Divide
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Divide
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Divide
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Divide
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Divide
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Divide
	 *     AdditionExpression returns Divide
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Divide
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Divide
	 *     MultiplicationExpression returns Divide
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Divide
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Divide
	 *     UnaryExpression returns Divide
	 *     UnaryExpressionNotPlusMinus returns Divide
	 *     PrimaryExpression returns Divide
	 *
	 * Constraint:
	 *     (left=MultiplicationExpression_Divide_1_0_0_1_0 right+=UnaryExpression)
	 * </pre>
	 */
	protected void sequence_MultiplicationExpression(ISerializationContext context, Divide semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Multiply
	 *     ConditionOrExpression returns Multiply
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Multiply
	 *     ConditionAndExpression returns Multiply
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Multiply
	 *     RelationOrExpression returns Multiply
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Multiply
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Multiply
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Multiply
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Multiply
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Multiply
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Multiply
	 *     AdditionExpression returns Multiply
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Multiply
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Multiply
	 *     MultiplicationExpression returns Multiply
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Multiply
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Multiply
	 *     UnaryExpression returns Multiply
	 *     UnaryExpressionNotPlusMinus returns Multiply
	 *     PrimaryExpression returns Multiply
	 *
	 * Constraint:
	 *     (left=MultiplicationExpression_Multiply_1_0_0_0_0 right+=UnaryExpression)
	 * </pre>
	 */
	protected void sequence_MultiplicationExpression(ISerializationContext context, Multiply semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     NotBooleanExpression returns Expression
	 *
	 * Constraint:
	 *     exp=UnaryExpression
	 * </pre>
	 */
	protected void sequence_NotBooleanExpression(ISerializationContext context, Expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotBooleanExpressionAccess().getExpUnaryExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Expression
	 *     ConditionOrExpression returns Expression
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Expression
	 *     ConditionAndExpression returns Expression
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Expression
	 *     RelationOrExpression returns Expression
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Expression
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Expression
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Expression
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Expression
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Expression
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Expression
	 *     AdditionExpression returns Expression
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Expression
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Expression
	 *     MultiplicationExpression returns Expression
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Expression
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Expression
	 *     UnaryExpression returns Expression
	 *     UnaryExpressionNotPlusMinus returns Expression
	 *     PrimaryExpression returns Expression
	 *
	 * Constraint:
	 *     (exp=UnaryExpression | var=[Variable|ID])
	 * </pre>
	 */
	protected void sequence_NotBooleanExpression_PrimaryExpression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (param=ID | param=ID | param=ID | param=ID | param=ID)
	 * </pre>
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns PlantFunction
	 *     BuiltinFunction returns PlantFunction
	 *     PlantFunction returns PlantFunction
	 *
	 * Constraint:
	 *     (plantInField=[Field|ID] plantCrop=[Crop|ID])
	 * </pre>
	 */
	protected void sequence_PlantFunction(ISerializationContext context, PlantFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.PLANT_FUNCTION__PLANT_IN_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.PLANT_FUNCTION__PLANT_IN_FIELD));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.PLANT_FUNCTION__PLANT_CROP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.PLANT_FUNCTION__PLANT_CROP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlantFunctionAccess().getPlantInFieldFieldIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.PLANT_FUNCTION__PLANT_IN_FIELD, false));
		feeder.accept(grammarAccess.getPlantFunctionAccess().getPlantCropCropIDTerminalRuleCall_2_0_1(), semanticObject.eGet(FarmPackage.Literals.PLANT_FUNCTION__PLANT_CROP, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns RealLiteral
	 *     ConditionOrExpression returns RealLiteral
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns RealLiteral
	 *     ConditionAndExpression returns RealLiteral
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns RealLiteral
	 *     RelationOrExpression returns RealLiteral
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns RealLiteral
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns RealLiteral
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns RealLiteral
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns RealLiteral
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns RealLiteral
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns RealLiteral
	 *     AdditionExpression returns RealLiteral
	 *     AdditionExpression.Plus_1_0_0_0_0 returns RealLiteral
	 *     AdditionExpression.Minus_1_0_0_1_0 returns RealLiteral
	 *     MultiplicationExpression returns RealLiteral
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns RealLiteral
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns RealLiteral
	 *     UnaryExpression returns RealLiteral
	 *     UnaryExpressionNotPlusMinus returns RealLiteral
	 *     PrimaryExpression returns RealLiteral
	 *     Literal returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     val=REAL
	 * </pre>
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.REAL_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.REAL_LITERAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getValREALParserRuleCall_1_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Equal
	 *     ConditionOrExpression returns Equal
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Equal
	 *     ConditionAndExpression returns Equal
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Equal
	 *     RelationOrExpression returns Equal
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Equal
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Equal
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Equal
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Equal
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Equal
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Equal
	 *     AdditionExpression returns Equal
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Equal
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Equal
	 *     MultiplicationExpression returns Equal
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Equal
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Equal
	 *     UnaryExpression returns Equal
	 *     UnaryExpressionNotPlusMinus returns Equal
	 *     PrimaryExpression returns Equal
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_Equal_1_0_0_4_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getEqualLeftAction_1_0_0_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns GreaterThan
	 *     ConditionOrExpression returns GreaterThan
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns GreaterThan
	 *     ConditionAndExpression returns GreaterThan
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns GreaterThan
	 *     RelationOrExpression returns GreaterThan
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns GreaterThan
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns GreaterThan
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns GreaterThan
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns GreaterThan
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns GreaterThan
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns GreaterThan
	 *     AdditionExpression returns GreaterThan
	 *     AdditionExpression.Plus_1_0_0_0_0 returns GreaterThan
	 *     AdditionExpression.Minus_1_0_0_1_0 returns GreaterThan
	 *     MultiplicationExpression returns GreaterThan
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns GreaterThan
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns GreaterThan
	 *     UnaryExpression returns GreaterThan
	 *     UnaryExpressionNotPlusMinus returns GreaterThan
	 *     PrimaryExpression returns GreaterThan
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_GreaterThan_1_0_0_3_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, GreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GREATER_THAN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GREATER_THAN__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GREATER_THAN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GREATER_THAN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getGreaterThanLeftAction_1_0_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns GreaterThanOrEqual
	 *     ConditionOrExpression returns GreaterThanOrEqual
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns GreaterThanOrEqual
	 *     ConditionAndExpression returns GreaterThanOrEqual
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns GreaterThanOrEqual
	 *     RelationOrExpression returns GreaterThanOrEqual
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns GreaterThanOrEqual
	 *     AdditionExpression returns GreaterThanOrEqual
	 *     AdditionExpression.Plus_1_0_0_0_0 returns GreaterThanOrEqual
	 *     AdditionExpression.Minus_1_0_0_1_0 returns GreaterThanOrEqual
	 *     MultiplicationExpression returns GreaterThanOrEqual
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns GreaterThanOrEqual
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns GreaterThanOrEqual
	 *     UnaryExpression returns GreaterThanOrEqual
	 *     UnaryExpressionNotPlusMinus returns GreaterThanOrEqual
	 *     PrimaryExpression returns GreaterThanOrEqual
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_GreaterThanOrEqual_1_0_0_2_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, GreaterThanOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GREATER_THAN_OR_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GREATER_THAN_OR_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GREATER_THAN_OR_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GREATER_THAN_OR_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getGreaterThanOrEqualLeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns LessThan
	 *     ConditionOrExpression returns LessThan
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns LessThan
	 *     ConditionAndExpression returns LessThan
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns LessThan
	 *     RelationOrExpression returns LessThan
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns LessThan
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns LessThan
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns LessThan
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns LessThan
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns LessThan
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns LessThan
	 *     AdditionExpression returns LessThan
	 *     AdditionExpression.Plus_1_0_0_0_0 returns LessThan
	 *     AdditionExpression.Minus_1_0_0_1_0 returns LessThan
	 *     MultiplicationExpression returns LessThan
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns LessThan
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns LessThan
	 *     UnaryExpression returns LessThan
	 *     UnaryExpressionNotPlusMinus returns LessThan
	 *     PrimaryExpression returns LessThan
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_LessThan_1_0_0_1_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, LessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.LESS_THAN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.LESS_THAN__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.LESS_THAN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.LESS_THAN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getLessThanLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns LessThanOrEqual
	 *     ConditionOrExpression returns LessThanOrEqual
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns LessThanOrEqual
	 *     ConditionAndExpression returns LessThanOrEqual
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns LessThanOrEqual
	 *     RelationOrExpression returns LessThanOrEqual
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns LessThanOrEqual
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns LessThanOrEqual
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns LessThanOrEqual
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns LessThanOrEqual
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns LessThanOrEqual
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns LessThanOrEqual
	 *     AdditionExpression returns LessThanOrEqual
	 *     AdditionExpression.Plus_1_0_0_0_0 returns LessThanOrEqual
	 *     AdditionExpression.Minus_1_0_0_1_0 returns LessThanOrEqual
	 *     MultiplicationExpression returns LessThanOrEqual
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns LessThanOrEqual
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns LessThanOrEqual
	 *     UnaryExpression returns LessThanOrEqual
	 *     UnaryExpressionNotPlusMinus returns LessThanOrEqual
	 *     PrimaryExpression returns LessThanOrEqual
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_LessThanOrEqual_1_0_0_0_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, LessThanOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.LESS_THAN_OR_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.LESS_THAN_OR_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.LESS_THAN_OR_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.LESS_THAN_OR_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getLessThanOrEqualLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NotEqual
	 *     ConditionOrExpression returns NotEqual
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns NotEqual
	 *     ConditionAndExpression returns NotEqual
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns NotEqual
	 *     RelationOrExpression returns NotEqual
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns NotEqual
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns NotEqual
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns NotEqual
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns NotEqual
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns NotEqual
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns NotEqual
	 *     AdditionExpression returns NotEqual
	 *     AdditionExpression.Plus_1_0_0_0_0 returns NotEqual
	 *     AdditionExpression.Minus_1_0_0_1_0 returns NotEqual
	 *     MultiplicationExpression returns NotEqual
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns NotEqual
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns NotEqual
	 *     UnaryExpression returns NotEqual
	 *     UnaryExpressionNotPlusMinus returns NotEqual
	 *     PrimaryExpression returns NotEqual
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_NotEqual_1_0_0_5_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, NotEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.NOT_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.NOT_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.NOT_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.NOT_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getNotEqualLeftAction_1_0_0_5_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ReportFunction
	 *     BuiltinFunction returns ReportFunction
	 *     ReportFunction returns ReportFunction
	 *
	 * Constraint:
	 *     entity=[Entity|ID]
	 * </pre>
	 */
	protected void sequence_ReportFunction(ISerializationContext context, ReportFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.REPORT_FUNCTION__ENTITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.REPORT_FUNCTION__ENTITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReportFunctionAccess().getEntityEntityIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FarmPackage.Literals.REPORT_FUNCTION__ENTITY, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     value=Expression
	 * </pre>
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.RETURN_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.RETURN_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReturnStatementAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SetFieldValueFunction
	 *     BuiltinFunction returns SetFieldValueFunction
	 *     SetFieldValueFunction returns SetFieldValueFunction
	 *
	 * Constraint:
	 *     (setValueField=[Field|ID] setFieldAttribute=STRING setFieldValue=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_SetFieldValueFunction(ISerializationContext context, SetFieldValueFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_VALUE_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_VALUE_FIELD));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_FIELD_ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_FIELD_ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_FIELD_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_FIELD_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetFieldValueFunctionAccess().getSetValueFieldFieldIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_VALUE_FIELD, false));
		feeder.accept(grammarAccess.getSetFieldValueFunctionAccess().getSetFieldAttributeSTRINGTerminalRuleCall_2_0(), semanticObject.getSetFieldAttribute());
		feeder.accept(grammarAccess.getSetFieldValueFunctionAccess().getSetFieldValueAdditionExpressionParserRuleCall_4_0(), semanticObject.getSetFieldValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TaskStatement returns TaskStatement
	 *
	 * Constraint:
	 *     (name=ID (parmas+=Param parmas+=Param*)? typeName=TypeName (taskStatements+=Statement | taskStatements+=ReturnStatement)*)
	 * </pre>
	 */
	protected void sequence_TaskStatement(ISerializationContext context, TaskStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns UnaryExpression
	 *     ConditionOrExpression returns UnaryExpression
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns UnaryExpression
	 *     ConditionAndExpression returns UnaryExpression
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns UnaryExpression
	 *     RelationOrExpression returns UnaryExpression
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns UnaryExpression
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns UnaryExpression
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns UnaryExpression
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns UnaryExpression
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns UnaryExpression
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns UnaryExpression
	 *     AdditionExpression returns UnaryExpression
	 *     AdditionExpression.Plus_1_0_0_0_0 returns UnaryExpression
	 *     AdditionExpression.Minus_1_0_0_1_0 returns UnaryExpression
	 *     MultiplicationExpression returns UnaryExpression
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns UnaryExpression
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *     UnaryExpressionNotPlusMinus returns UnaryExpression
	 *     PrimaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     exp=UnaryExpression
	 * </pre>
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getExpUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Variable
	 *     Entity returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID expression=Expression)
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.ENTITY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.ENTITY__NAME));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.VARIABLE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.VARIABLE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns WaitFunction
	 *     BuiltinFunction returns WaitFunction
	 *     WaitFunction returns WaitFunction
	 *
	 * Constraint:
	 *     value=AdditionExpression
	 * </pre>
	 */
	protected void sequence_WaitFunction(ISerializationContext context, WaitFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.WAIT_FUNCTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.WAIT_FUNCTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWaitFunctionAccess().getValueAdditionExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}

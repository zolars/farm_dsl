/*
 * generated by Xtext 2.26.0
 */
package uk.ac.kcl.farm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.farm.farm.Addition;
import uk.ac.kcl.farm.farm.AndExpression;
import uk.ac.kcl.farm.farm.AttributeDeclaration;
import uk.ac.kcl.farm.farm.BooleanLiteral;
import uk.ac.kcl.farm.farm.BooleanVarExpression;
import uk.ac.kcl.farm.farm.ComparisonExpression;
import uk.ac.kcl.farm.farm.Crop;
import uk.ac.kcl.farm.farm.CropAttributes;
import uk.ac.kcl.farm.farm.CropStage;
import uk.ac.kcl.farm.farm.CropStages;
import uk.ac.kcl.farm.farm.FarmPackage;
import uk.ac.kcl.farm.farm.FarmProgram;
import uk.ac.kcl.farm.farm.Field;
import uk.ac.kcl.farm.farm.LoopStatement;
import uk.ac.kcl.farm.farm.Machine;
import uk.ac.kcl.farm.farm.Mission;
import uk.ac.kcl.farm.farm.Multiplication;
import uk.ac.kcl.farm.farm.OrExpression;
import uk.ac.kcl.farm.farm.Param;
import uk.ac.kcl.farm.farm.RealLiteral;
import uk.ac.kcl.farm.farm.RealVarExpression;
import uk.ac.kcl.farm.farm.Task;
import uk.ac.kcl.farm.farm.VariableDeclaration;
import uk.ac.kcl.farm.services.FarmGrammarAccess;

@SuppressWarnings("all")
public class FarmSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FarmGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FarmPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FarmPackage.ADDITION:
				sequence_Addition(context, (Addition) semanticObject); 
				return; 
			case FarmPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case FarmPackage.ATTRIBUTE_DECLARATION:
				sequence_AttributeDeclaration(context, (AttributeDeclaration) semanticObject); 
				return; 
			case FarmPackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case FarmPackage.BOOLEAN_VAR_EXPRESSION:
				sequence_BooleanVarExpression(context, (BooleanVarExpression) semanticObject); 
				return; 
			case FarmPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case FarmPackage.CROP:
				sequence_Crop(context, (Crop) semanticObject); 
				return; 
			case FarmPackage.CROP_ATTRIBUTES:
				sequence_CropAttributes(context, (CropAttributes) semanticObject); 
				return; 
			case FarmPackage.CROP_STAGE:
				sequence_CropStage(context, (CropStage) semanticObject); 
				return; 
			case FarmPackage.CROP_STAGES:
				sequence_CropStages(context, (CropStages) semanticObject); 
				return; 
			case FarmPackage.FARM_PROGRAM:
				sequence_FarmProgram(context, (FarmProgram) semanticObject); 
				return; 
			case FarmPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case FarmPackage.LOOP_STATEMENT:
				sequence_LoopStatement(context, (LoopStatement) semanticObject); 
				return; 
			case FarmPackage.MACHINE:
				sequence_Machine(context, (Machine) semanticObject); 
				return; 
			case FarmPackage.MISSION:
				sequence_Mission(context, (Mission) semanticObject); 
				return; 
			case FarmPackage.MULTIPLICATION:
				sequence_Multiplication(context, (Multiplication) semanticObject); 
				return; 
			case FarmPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case FarmPackage.PARAM:
				sequence_Param(context, (Param) semanticObject); 
				return; 
			case FarmPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case FarmPackage.REAL_VAR_EXPRESSION:
				sequence_RealVarExpression(context, (RealVarExpression) semanticObject); 
				return; 
			case FarmPackage.TASK:
				sequence_Task(context, (Task) semanticObject); 
				return; 
			case FarmPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableExpression returns Addition
	 *     RealExpression returns Addition
	 *     Addition returns Addition
	 *     Addition.Addition_1_0 returns Addition
	 *     Multiplication returns Addition
	 *     Multiplication.Multiplication_1_0 returns Addition
	 *     RealPrimary returns Addition
	 *
	 * Constraint:
	 *     (left=Addition_Addition_1_0 (operator+='+' | operator+='-') right+=Multiplication)
	 * </pre>
	 */
	protected void sequence_Addition(ISerializationContext context, Addition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableExpression returns AndExpression
	 *     ConditionExpression returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     ComparisonExpression returns AndExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns AndExpression
	 *     BooleanPrimary returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 operator+='&&' right+=ComparisonExpression)
	 * </pre>
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     AttributeDeclaration returns AttributeDeclaration
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_AttributeDeclaration(ISerializationContext context, AttributeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.ATTRIBUTE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.ATTRIBUTE_DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableExpression returns BooleanLiteral
	 *     ConditionExpression returns BooleanLiteral
	 *     OrExpression returns BooleanLiteral
	 *     OrExpression.OrExpression_1_0 returns BooleanLiteral
	 *     AndExpression returns BooleanLiteral
	 *     AndExpression.AndExpression_1_0 returns BooleanLiteral
	 *     ComparisonExpression returns BooleanLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns BooleanLiteral
	 *     BooleanPrimary returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     val='true'
	 * </pre>
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.BOOLEAN_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.BOOLEAN_LITERAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralAccess().getValTrueKeyword_0_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableExpression returns BooleanVarExpression
	 *     ConditionExpression returns BooleanVarExpression
	 *     OrExpression returns BooleanVarExpression
	 *     OrExpression.OrExpression_1_0 returns BooleanVarExpression
	 *     AndExpression returns BooleanVarExpression
	 *     AndExpression.AndExpression_1_0 returns BooleanVarExpression
	 *     ComparisonExpression returns BooleanVarExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns BooleanVarExpression
	 *     BooleanPrimary returns BooleanVarExpression
	 *     BooleanVarExpression returns BooleanVarExpression
	 *
	 * Constraint:
	 *     var=[VariableDeclaration|ID]
	 * </pre>
	 */
	protected void sequence_BooleanVarExpression(ISerializationContext context, BooleanVarExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.BOOLEAN_VAR_EXPRESSION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.BOOLEAN_VAR_EXPRESSION__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanVarExpressionAccess().getVarVariableDeclarationIDTerminalRuleCall_0_1(), semanticObject.eGet(FarmPackage.Literals.BOOLEAN_VAR_EXPRESSION__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableExpression returns ComparisonExpression
	 *     ConditionExpression returns ComparisonExpression
	 *     OrExpression returns ComparisonExpression
	 *     OrExpression.OrExpression_1_0 returns ComparisonExpression
	 *     AndExpression returns ComparisonExpression
	 *     AndExpression.AndExpression_1_0 returns ComparisonExpression
	 *     ComparisonExpression returns ComparisonExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ComparisonExpression
	 *     BooleanPrimary returns ComparisonExpression
	 *
	 * Constraint:
	 *     (
	 *         left=ComparisonExpression_ComparisonExpression_1_0 
	 *         (operator='&lt;' | operator='&lt;=' | operator='==' | operator='&gt;=' | operator='&gt;') 
	 *         right=BooleanPrimary
	 *     )
	 * </pre>
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CropAttributes returns CropAttributes
	 *
	 * Constraint:
	 *     (type=[AttributeDeclaration|ID] value=RealExpression)
	 * </pre>
	 */
	protected void sequence_CropAttributes(ISerializationContext context, CropAttributes semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__TYPE));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCropAttributesAccess().getTypeAttributeDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.CROP_ATTRIBUTES__TYPE, false));
		feeder.accept(grammarAccess.getCropAttributesAccess().getValueRealExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CropStage returns CropStage
	 *
	 * Constraint:
	 *     (name=STRING timeConsumend=RealExpression elements+=CropAttributes*)
	 * </pre>
	 */
	protected void sequence_CropStage(ISerializationContext context, CropStage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CropStages returns CropStages
	 *
	 * Constraint:
	 *     (elements+=CropStage elements+=CropStage*)
	 * </pre>
	 */
	protected void sequence_CropStages(ISerializationContext context, CropStages semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Class returns Crop
	 *     Crop returns Crop
	 *
	 * Constraint:
	 *     (crop=ID cropName=STRING statements+=CropStages)
	 * </pre>
	 */
	protected void sequence_Crop(ISerializationContext context, Crop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FarmProgram returns FarmProgram
	 *
	 * Constraint:
	 *     (statements+=Class | statements+=AttributeDeclaration)+
	 * </pre>
	 */
	protected void sequence_FarmProgram(ISerializationContext context, FarmProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Class returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.FIELD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LoopStatement
	 *     LoopStatement returns LoopStatement
	 *
	 * Constraint:
	 *     (condition=ConditionExpression statements+=Statement+)
	 * </pre>
	 */
	protected void sequence_LoopStatement(ISerializationContext context, LoopStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Class returns Machine
	 *     Machine returns Machine
	 *
	 * Constraint:
	 *     (name=ID machineName=STRING ip=IP statements+=Task+)
	 * </pre>
	 */
	protected void sequence_Machine(ISerializationContext context, Machine semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Class returns Mission
	 *     Mission returns Mission
	 *
	 * Constraint:
	 *     (name=ID (statements+=Statement | statements+=Task)+)
	 * </pre>
	 */
	protected void sequence_Mission(ISerializationContext context, Mission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableExpression returns Multiplication
	 *     RealExpression returns Multiplication
	 *     Addition returns Multiplication
	 *     Addition.Addition_1_0 returns Multiplication
	 *     Multiplication returns Multiplication
	 *     Multiplication.Multiplication_1_0 returns Multiplication
	 *     RealPrimary returns Multiplication
	 *
	 * Constraint:
	 *     (left=Multiplication_Multiplication_1_0 (operator+='*' | operator+='/') right+=RealPrimary)
	 * </pre>
	 */
	protected void sequence_Multiplication(ISerializationContext context, Multiplication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableExpression returns OrExpression
	 *     ConditionExpression returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     ComparisonExpression returns OrExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns OrExpression
	 *     BooleanPrimary returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0 operator+='||' right+=AndExpression)
	 * </pre>
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Param returns Param
	 *
	 * Constraint:
	 *     (
	 *         param=ID | 
	 *         param=ID | 
	 *         param=ID | 
	 *         param=ID | 
	 *         param=ID | 
	 *         param=ID
	 *     )
	 * </pre>
	 */
	protected void sequence_Param(ISerializationContext context, Param semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableExpression returns RealLiteral
	 *     RealExpression returns RealLiteral
	 *     Addition returns RealLiteral
	 *     Addition.Addition_1_0 returns RealLiteral
	 *     Multiplication returns RealLiteral
	 *     Multiplication.Multiplication_1_0 returns RealLiteral
	 *     RealPrimary returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     val=REAL
	 * </pre>
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.REAL_LITERAL__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.REAL_LITERAL__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getValREALParserRuleCall_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VariableExpression returns RealVarExpression
	 *     RealExpression returns RealVarExpression
	 *     Addition returns RealVarExpression
	 *     Addition.Addition_1_0 returns RealVarExpression
	 *     Multiplication returns RealVarExpression
	 *     Multiplication.Multiplication_1_0 returns RealVarExpression
	 *     RealPrimary returns RealVarExpression
	 *     RealVarExpression returns RealVarExpression
	 *
	 * Constraint:
	 *     var=[VariableDeclaration|ID]
	 * </pre>
	 */
	protected void sequence_RealVarExpression(ISerializationContext context, RealVarExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.REAL_VAR_EXPRESSION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.REAL_VAR_EXPRESSION__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealVarExpressionAccess().getVarVariableDeclarationIDTerminalRuleCall_0_1(), semanticObject.eGet(FarmPackage.Literals.REAL_VAR_EXPRESSION__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Task returns Task
	 *
	 * Constraint:
	 *     (name=ID (parmas+=Param parmas+=Param*)? typeName=TypeName statements+=Statement*)
	 * </pre>
	 */
	protected void sequence_Task(ISerializationContext context, Task semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (name=ID value=VariableExpression)
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.VARIABLE_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.VARIABLE_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getValueVariableExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}

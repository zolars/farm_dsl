/*
 * generated by Xtext 2.26.0
 */
package uk.ac.kcl.farm.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.kcl.farm.farm.Assignment;
import uk.ac.kcl.farm.farm.Attribute;
import uk.ac.kcl.farm.farm.ConditionAndExpression;
import uk.ac.kcl.farm.farm.ConditionOrExpression;
import uk.ac.kcl.farm.farm.CountStageFunction;
import uk.ac.kcl.farm.farm.Crop;
import uk.ac.kcl.farm.farm.CropAttributes;
import uk.ac.kcl.farm.farm.CropStage;
import uk.ac.kcl.farm.farm.CropStages;
import uk.ac.kcl.farm.farm.Divide;
import uk.ac.kcl.farm.farm.ElseJudgeStatement;
import uk.ac.kcl.farm.farm.ElseStatement;
import uk.ac.kcl.farm.farm.Equal;
import uk.ac.kcl.farm.farm.FalseLiteral;
import uk.ac.kcl.farm.farm.FarmPackage;
import uk.ac.kcl.farm.farm.FarmProgram;
import uk.ac.kcl.farm.farm.Field;
import uk.ac.kcl.farm.farm.FieldMonitor;
import uk.ac.kcl.farm.farm.GreaterThan;
import uk.ac.kcl.farm.farm.GreaterThanOrEqual;
import uk.ac.kcl.farm.farm.JudgeStatement;
import uk.ac.kcl.farm.farm.LessThan;
import uk.ac.kcl.farm.farm.LessThanOrEqual;
import uk.ac.kcl.farm.farm.LoopStatement;
import uk.ac.kcl.farm.farm.Minus;
import uk.ac.kcl.farm.farm.Mission;
import uk.ac.kcl.farm.farm.MoveFunction;
import uk.ac.kcl.farm.farm.Multiply;
import uk.ac.kcl.farm.farm.NotBooleanExpression;
import uk.ac.kcl.farm.farm.NotEqual;
import uk.ac.kcl.farm.farm.PlantFunction;
import uk.ac.kcl.farm.farm.Plus;
import uk.ac.kcl.farm.farm.RealLiteral;
import uk.ac.kcl.farm.farm.ReportFunction;
import uk.ac.kcl.farm.farm.SetFieldValueFunction;
import uk.ac.kcl.farm.farm.TrueLiteral;
import uk.ac.kcl.farm.farm.UnaryExpression;
import uk.ac.kcl.farm.farm.VarExpression;
import uk.ac.kcl.farm.farm.Variable;
import uk.ac.kcl.farm.farm.WaitFunction;
import uk.ac.kcl.farm.services.FarmGrammarAccess;

@SuppressWarnings("all")
public class FarmSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private FarmGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == FarmPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case FarmPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case FarmPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case FarmPackage.CONDITION_AND_EXPRESSION:
				sequence_ConditionAndExpression(context, (ConditionAndExpression) semanticObject); 
				return; 
			case FarmPackage.CONDITION_OR_EXPRESSION:
				sequence_ConditionOrExpression(context, (ConditionOrExpression) semanticObject); 
				return; 
			case FarmPackage.COUNT_STAGE_FUNCTION:
				sequence_CountStageFunction(context, (CountStageFunction) semanticObject); 
				return; 
			case FarmPackage.CROP:
				sequence_Crop(context, (Crop) semanticObject); 
				return; 
			case FarmPackage.CROP_ATTRIBUTES:
				sequence_CropAttributes(context, (CropAttributes) semanticObject); 
				return; 
			case FarmPackage.CROP_STAGE:
				sequence_CropStage(context, (CropStage) semanticObject); 
				return; 
			case FarmPackage.CROP_STAGES:
				sequence_CropStages(context, (CropStages) semanticObject); 
				return; 
			case FarmPackage.DIVIDE:
				sequence_MultiplicationExpression(context, (Divide) semanticObject); 
				return; 
			case FarmPackage.ELSE_JUDGE_STATEMENT:
				sequence_ElseJudgeStatement(context, (ElseJudgeStatement) semanticObject); 
				return; 
			case FarmPackage.ELSE_STATEMENT:
				sequence_ElseStatement(context, (ElseStatement) semanticObject); 
				return; 
			case FarmPackage.EQUAL:
				sequence_RelationOrExpression(context, (Equal) semanticObject); 
				return; 
			case FarmPackage.FALSE_LITERAL:
				sequence_FalseLiteral(context, (FalseLiteral) semanticObject); 
				return; 
			case FarmPackage.FARM_PROGRAM:
				sequence_FarmProgram(context, (FarmProgram) semanticObject); 
				return; 
			case FarmPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case FarmPackage.FIELD_MONITOR:
				sequence_FieldMonitor(context, (FieldMonitor) semanticObject); 
				return; 
			case FarmPackage.GREATER_THAN:
				sequence_RelationOrExpression(context, (GreaterThan) semanticObject); 
				return; 
			case FarmPackage.GREATER_THAN_OR_EQUAL:
				sequence_RelationOrExpression(context, (GreaterThanOrEqual) semanticObject); 
				return; 
			case FarmPackage.JUDGE_STATEMENT:
				sequence_JudgeStatement(context, (JudgeStatement) semanticObject); 
				return; 
			case FarmPackage.LESS_THAN:
				sequence_RelationOrExpression(context, (LessThan) semanticObject); 
				return; 
			case FarmPackage.LESS_THAN_OR_EQUAL:
				sequence_RelationOrExpression(context, (LessThanOrEqual) semanticObject); 
				return; 
			case FarmPackage.LOOP_STATEMENT:
				sequence_LoopStatement(context, (LoopStatement) semanticObject); 
				return; 
			case FarmPackage.MINUS:
				sequence_AdditionExpression(context, (Minus) semanticObject); 
				return; 
			case FarmPackage.MISSION:
				sequence_Mission(context, (Mission) semanticObject); 
				return; 
			case FarmPackage.MOVE_FUNCTION:
				sequence_MoveFunction(context, (MoveFunction) semanticObject); 
				return; 
			case FarmPackage.MULTIPLY:
				sequence_MultiplicationExpression(context, (Multiply) semanticObject); 
				return; 
			case FarmPackage.NOT_BOOLEAN_EXPRESSION:
				sequence_NotBooleanExpression(context, (NotBooleanExpression) semanticObject); 
				return; 
			case FarmPackage.NOT_EQUAL:
				sequence_RelationOrExpression(context, (NotEqual) semanticObject); 
				return; 
			case FarmPackage.PLANT_FUNCTION:
				sequence_PlantFunction(context, (PlantFunction) semanticObject); 
				return; 
			case FarmPackage.PLUS:
				sequence_AdditionExpression(context, (Plus) semanticObject); 
				return; 
			case FarmPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case FarmPackage.REPORT_FUNCTION:
				sequence_ReportFunction(context, (ReportFunction) semanticObject); 
				return; 
			case FarmPackage.SET_FIELD_VALUE_FUNCTION:
				sequence_SetFieldValueFunction(context, (SetFieldValueFunction) semanticObject); 
				return; 
			case FarmPackage.TRUE_LITERAL:
				sequence_TrueLiteral(context, (TrueLiteral) semanticObject); 
				return; 
			case FarmPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case FarmPackage.VAR_EXPRESSION:
				sequence_VarExpression(context, (VarExpression) semanticObject); 
				return; 
			case FarmPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case FarmPackage.WAIT_FUNCTION:
				sequence_WaitFunction(context, (WaitFunction) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Minus
	 *     ConditionOrExpression returns Minus
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Minus
	 *     ConditionAndExpression returns Minus
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Minus
	 *     RelationOrExpression returns Minus
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Minus
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Minus
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Minus
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Minus
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Minus
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Minus
	 *     AdditionExpression returns Minus
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Minus
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Minus
	 *     MultiplicationExpression returns Minus
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Minus
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Minus
	 *     UnaryExpression returns Minus
	 *     UnaryExpressionNotPlusMinus returns Minus
	 *     PrimaryExpression returns Minus
	 *
	 * Constraint:
	 *     (left=AdditionExpression_Minus_1_0_0_1_0 right=MultiplicationExpression)
	 * </pre>
	 */
	protected void sequence_AdditionExpression(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionExpressionAccess().getMinusLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionExpressionAccess().getRightMultiplicationExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Plus
	 *     ConditionOrExpression returns Plus
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Plus
	 *     ConditionAndExpression returns Plus
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Plus
	 *     RelationOrExpression returns Plus
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Plus
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Plus
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Plus
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Plus
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Plus
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Plus
	 *     AdditionExpression returns Plus
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Plus
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Plus
	 *     MultiplicationExpression returns Plus
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Plus
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Plus
	 *     UnaryExpression returns Plus
	 *     UnaryExpressionNotPlusMinus returns Plus
	 *     PrimaryExpression returns Plus
	 *
	 * Constraint:
	 *     (left=AdditionExpression_Plus_1_0_0_0_0 right=MultiplicationExpression)
	 * </pre>
	 */
	protected void sequence_AdditionExpression(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditionExpressionAccess().getPlusLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditionExpressionAccess().getRightMultiplicationExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (var=[Variable|ID] expression=Expression)
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.ASSIGNMENT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.ASSIGNMENT__VAR));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getVarVariableIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.ASSIGNMENT__VAR, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     name=ID
	 * </pre>
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.ATTRIBUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ConditionAndExpression
	 *     ConditionOrExpression returns ConditionAndExpression
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns ConditionAndExpression
	 *     ConditionAndExpression returns ConditionAndExpression
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns ConditionAndExpression
	 *     RelationOrExpression returns ConditionAndExpression
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns ConditionAndExpression
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns ConditionAndExpression
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns ConditionAndExpression
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns ConditionAndExpression
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns ConditionAndExpression
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns ConditionAndExpression
	 *     AdditionExpression returns ConditionAndExpression
	 *     AdditionExpression.Plus_1_0_0_0_0 returns ConditionAndExpression
	 *     AdditionExpression.Minus_1_0_0_1_0 returns ConditionAndExpression
	 *     MultiplicationExpression returns ConditionAndExpression
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns ConditionAndExpression
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns ConditionAndExpression
	 *     UnaryExpression returns ConditionAndExpression
	 *     UnaryExpressionNotPlusMinus returns ConditionAndExpression
	 *     PrimaryExpression returns ConditionAndExpression
	 *
	 * Constraint:
	 *     (left=ConditionAndExpression_ConditionAndExpression_1_0_0 right=RelationOrExpression)
	 * </pre>
	 */
	protected void sequence_ConditionAndExpression(ISerializationContext context, ConditionAndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CONDITION_AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CONDITION_AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CONDITION_AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CONDITION_AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionAndExpressionAccess().getConditionAndExpressionLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionAndExpressionAccess().getRightRelationOrExpressionParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ConditionOrExpression
	 *     ConditionOrExpression returns ConditionOrExpression
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns ConditionOrExpression
	 *     ConditionAndExpression returns ConditionOrExpression
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns ConditionOrExpression
	 *     RelationOrExpression returns ConditionOrExpression
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns ConditionOrExpression
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns ConditionOrExpression
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns ConditionOrExpression
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns ConditionOrExpression
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns ConditionOrExpression
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns ConditionOrExpression
	 *     AdditionExpression returns ConditionOrExpression
	 *     AdditionExpression.Plus_1_0_0_0_0 returns ConditionOrExpression
	 *     AdditionExpression.Minus_1_0_0_1_0 returns ConditionOrExpression
	 *     MultiplicationExpression returns ConditionOrExpression
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns ConditionOrExpression
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns ConditionOrExpression
	 *     UnaryExpression returns ConditionOrExpression
	 *     UnaryExpressionNotPlusMinus returns ConditionOrExpression
	 *     PrimaryExpression returns ConditionOrExpression
	 *
	 * Constraint:
	 *     (left=ConditionOrExpression_ConditionOrExpression_1_0_0 right=ConditionAndExpression)
	 * </pre>
	 */
	protected void sequence_ConditionOrExpression(ISerializationContext context, ConditionOrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CONDITION_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CONDITION_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CONDITION_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CONDITION_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionOrExpressionAccess().getConditionOrExpressionLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConditionOrExpressionAccess().getRightConditionAndExpressionParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns CountStageFunction
	 *     BuiltinFunction returns CountStageFunction
	 *     CountStageFunction returns CountStageFunction
	 *
	 * Constraint:
	 *     countStageCrop=[Crop|ID]
	 * </pre>
	 */
	protected void sequence_CountStageFunction(ISerializationContext context, CountStageFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.COUNT_STAGE_FUNCTION__COUNT_STAGE_CROP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.COUNT_STAGE_FUNCTION__COUNT_STAGE_CROP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountStageFunctionAccess().getCountStageCropCropIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.COUNT_STAGE_FUNCTION__COUNT_STAGE_CROP, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CropAttributes returns CropAttributes
	 *
	 * Constraint:
	 *     (type=[Attribute|ID] value=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_CropAttributes(ISerializationContext context, CropAttributes semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__TYPE));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.CROP_ATTRIBUTES__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCropAttributesAccess().getTypeAttributeIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.CROP_ATTRIBUTES__TYPE, false));
		feeder.accept(grammarAccess.getCropAttributesAccess().getValueAdditionExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CropStage returns CropStage
	 *
	 * Constraint:
	 *     (name=STRING time=AdditionExpression attributes+=CropAttributes*)
	 * </pre>
	 */
	protected void sequence_CropStage(ISerializationContext context, CropStage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CropStages returns CropStages
	 *
	 * Constraint:
	 *     (elements+=CropStage elements+=CropStage*)
	 * </pre>
	 */
	protected void sequence_CropStages(ISerializationContext context, CropStages semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instance returns Crop
	 *     Crop returns Crop
	 *
	 * Constraint:
	 *     (name=ID cropName=STRING cropStages+=CropStages)
	 * </pre>
	 */
	protected void sequence_Crop(ISerializationContext context, Crop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElseJudgeStatement returns ElseJudgeStatement
	 *
	 * Constraint:
	 *     (condition=Expression elseJudgeStatements+=Statement*)
	 * </pre>
	 */
	protected void sequence_ElseJudgeStatement(ISerializationContext context, ElseJudgeStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ElseStatement returns ElseStatement
	 *
	 * Constraint:
	 *     elseStatements+=Statement*
	 * </pre>
	 */
	protected void sequence_ElseStatement(ISerializationContext context, ElseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns FalseLiteral
	 *     ConditionOrExpression returns FalseLiteral
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns FalseLiteral
	 *     ConditionAndExpression returns FalseLiteral
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns FalseLiteral
	 *     RelationOrExpression returns FalseLiteral
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns FalseLiteral
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns FalseLiteral
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns FalseLiteral
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns FalseLiteral
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns FalseLiteral
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns FalseLiteral
	 *     AdditionExpression returns FalseLiteral
	 *     AdditionExpression.Plus_1_0_0_0_0 returns FalseLiteral
	 *     AdditionExpression.Minus_1_0_0_1_0 returns FalseLiteral
	 *     MultiplicationExpression returns FalseLiteral
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns FalseLiteral
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns FalseLiteral
	 *     UnaryExpression returns FalseLiteral
	 *     UnaryExpressionNotPlusMinus returns FalseLiteral
	 *     PrimaryExpression returns FalseLiteral
	 *     Literal returns FalseLiteral
	 *     FalseLiteral returns FalseLiteral
	 *
	 * Constraint:
	 *     value='false'
	 * </pre>
	 */
	protected void sequence_FalseLiteral(ISerializationContext context, FalseLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.FALSE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.FALSE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFalseLiteralAccess().getValueFalseKeyword_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FarmProgram returns FarmProgram
	 *
	 * Constraint:
	 *     (statements+=Attribute | statements+=Crop | statements+=Field | statements+=Mission)+
	 * </pre>
	 */
	protected void sequence_FarmProgram(ISerializationContext context, FarmProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FieldMonitor returns FieldMonitor
	 *
	 * Constraint:
	 *     monitor=[Attribute|ID]
	 * </pre>
	 */
	protected void sequence_FieldMonitor(ISerializationContext context, FieldMonitor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.FIELD_MONITOR__MONITOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.FIELD_MONITOR__MONITOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldMonitorAccess().getMonitorAttributeIDTerminalRuleCall_0_1(), semanticObject.eGet(FarmPackage.Literals.FIELD_MONITOR__MONITOR, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Instance returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         fieldName=STRING 
	 *         fieldIP=STRING 
	 *         (fieldType='inside' | fieldType='outside') 
	 *         (fieldLight='sunlight' | fieldLight='LED') 
	 *         fieldMonitors+=FieldMonitor 
	 *         fieldMonitors+=FieldMonitor*
	 *     )
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns JudgeStatement
	 *     JudgeStatement returns JudgeStatement
	 *
	 * Constraint:
	 *     (condition=Expression judgeStatements+=Statement* elseJudgeStatements+=ElseJudgeStatement* elseStatement+=ElseStatement?)
	 * </pre>
	 */
	protected void sequence_JudgeStatement(ISerializationContext context, JudgeStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns LoopStatement
	 *     LoopStatement returns LoopStatement
	 *
	 * Constraint:
	 *     (condition=Expression loopStatements+=Statement*)
	 * </pre>
	 */
	protected void sequence_LoopStatement(ISerializationContext context, LoopStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Mission returns Mission
	 *
	 * Constraint:
	 *     missionStatements+=Statement+
	 * </pre>
	 */
	protected void sequence_Mission(ISerializationContext context, Mission semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns MoveFunction
	 *     BuiltinFunction returns MoveFunction
	 *     MoveFunction returns MoveFunction
	 *
	 * Constraint:
	 *     (moveFromField=[Field|ID] moveToField=[Field|ID])
	 * </pre>
	 */
	protected void sequence_MoveFunction(ISerializationContext context, MoveFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.MOVE_FUNCTION__MOVE_FROM_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.MOVE_FUNCTION__MOVE_FROM_FIELD));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.MOVE_FUNCTION__MOVE_TO_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.MOVE_FUNCTION__MOVE_TO_FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoveFunctionAccess().getMoveFromFieldFieldIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FarmPackage.Literals.MOVE_FUNCTION__MOVE_FROM_FIELD, false));
		feeder.accept(grammarAccess.getMoveFunctionAccess().getMoveToFieldFieldIDTerminalRuleCall_3_0_1(), semanticObject.eGet(FarmPackage.Literals.MOVE_FUNCTION__MOVE_TO_FIELD, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Divide
	 *     ConditionOrExpression returns Divide
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Divide
	 *     ConditionAndExpression returns Divide
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Divide
	 *     RelationOrExpression returns Divide
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Divide
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Divide
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Divide
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Divide
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Divide
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Divide
	 *     AdditionExpression returns Divide
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Divide
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Divide
	 *     MultiplicationExpression returns Divide
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Divide
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Divide
	 *     UnaryExpression returns Divide
	 *     UnaryExpressionNotPlusMinus returns Divide
	 *     PrimaryExpression returns Divide
	 *
	 * Constraint:
	 *     (left=MultiplicationExpression_Divide_1_0_0_1_0 right=UnaryExpression)
	 * </pre>
	 */
	protected void sequence_MultiplicationExpression(ISerializationContext context, Divide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.DIVIDE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.DIVIDE__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.DIVIDE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.DIVIDE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationExpressionAccess().getDivideLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationExpressionAccess().getRightUnaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Multiply
	 *     ConditionOrExpression returns Multiply
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Multiply
	 *     ConditionAndExpression returns Multiply
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Multiply
	 *     RelationOrExpression returns Multiply
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Multiply
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Multiply
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Multiply
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Multiply
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Multiply
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Multiply
	 *     AdditionExpression returns Multiply
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Multiply
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Multiply
	 *     MultiplicationExpression returns Multiply
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Multiply
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Multiply
	 *     UnaryExpression returns Multiply
	 *     UnaryExpressionNotPlusMinus returns Multiply
	 *     PrimaryExpression returns Multiply
	 *
	 * Constraint:
	 *     (left=MultiplicationExpression_Multiply_1_0_0_0_0 right=UnaryExpression)
	 * </pre>
	 */
	protected void sequence_MultiplicationExpression(ISerializationContext context, Multiply semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.MULTIPLY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.MULTIPLY__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.MULTIPLY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.MULTIPLY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationExpressionAccess().getMultiplyLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationExpressionAccess().getRightUnaryExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NotBooleanExpression
	 *     ConditionOrExpression returns NotBooleanExpression
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns NotBooleanExpression
	 *     ConditionAndExpression returns NotBooleanExpression
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns NotBooleanExpression
	 *     RelationOrExpression returns NotBooleanExpression
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns NotBooleanExpression
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns NotBooleanExpression
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns NotBooleanExpression
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns NotBooleanExpression
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns NotBooleanExpression
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns NotBooleanExpression
	 *     AdditionExpression returns NotBooleanExpression
	 *     AdditionExpression.Plus_1_0_0_0_0 returns NotBooleanExpression
	 *     AdditionExpression.Minus_1_0_0_1_0 returns NotBooleanExpression
	 *     MultiplicationExpression returns NotBooleanExpression
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns NotBooleanExpression
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns NotBooleanExpression
	 *     UnaryExpression returns NotBooleanExpression
	 *     UnaryExpressionNotPlusMinus returns NotBooleanExpression
	 *     NotBooleanExpression returns NotBooleanExpression
	 *     PrimaryExpression returns NotBooleanExpression
	 *
	 * Constraint:
	 *     exp=UnaryExpression
	 * </pre>
	 */
	protected void sequence_NotBooleanExpression(ISerializationContext context, NotBooleanExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.NOT_BOOLEAN_EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.NOT_BOOLEAN_EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotBooleanExpressionAccess().getExpUnaryExpressionParserRuleCall_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns PlantFunction
	 *     BuiltinFunction returns PlantFunction
	 *     PlantFunction returns PlantFunction
	 *
	 * Constraint:
	 *     (plantInField=[Field|ID] plantCrop=[Crop|ID])
	 * </pre>
	 */
	protected void sequence_PlantFunction(ISerializationContext context, PlantFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.PLANT_FUNCTION__PLANT_IN_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.PLANT_FUNCTION__PLANT_IN_FIELD));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.PLANT_FUNCTION__PLANT_CROP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.PLANT_FUNCTION__PLANT_CROP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlantFunctionAccess().getPlantInFieldFieldIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.PLANT_FUNCTION__PLANT_IN_FIELD, false));
		feeder.accept(grammarAccess.getPlantFunctionAccess().getPlantCropCropIDTerminalRuleCall_2_0_1(), semanticObject.eGet(FarmPackage.Literals.PLANT_FUNCTION__PLANT_CROP, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns RealLiteral
	 *     ConditionOrExpression returns RealLiteral
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns RealLiteral
	 *     ConditionAndExpression returns RealLiteral
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns RealLiteral
	 *     RelationOrExpression returns RealLiteral
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns RealLiteral
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns RealLiteral
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns RealLiteral
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns RealLiteral
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns RealLiteral
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns RealLiteral
	 *     AdditionExpression returns RealLiteral
	 *     AdditionExpression.Plus_1_0_0_0_0 returns RealLiteral
	 *     AdditionExpression.Minus_1_0_0_1_0 returns RealLiteral
	 *     MultiplicationExpression returns RealLiteral
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns RealLiteral
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns RealLiteral
	 *     UnaryExpression returns RealLiteral
	 *     UnaryExpressionNotPlusMinus returns RealLiteral
	 *     PrimaryExpression returns RealLiteral
	 *     Literal returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     num=REAL
	 * </pre>
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.REAL_LITERAL__NUM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.REAL_LITERAL__NUM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getNumREALParserRuleCall_1_0(), semanticObject.getNum());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Equal
	 *     ConditionOrExpression returns Equal
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns Equal
	 *     ConditionAndExpression returns Equal
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns Equal
	 *     RelationOrExpression returns Equal
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns Equal
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns Equal
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns Equal
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns Equal
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns Equal
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns Equal
	 *     AdditionExpression returns Equal
	 *     AdditionExpression.Plus_1_0_0_0_0 returns Equal
	 *     AdditionExpression.Minus_1_0_0_1_0 returns Equal
	 *     MultiplicationExpression returns Equal
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns Equal
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns Equal
	 *     UnaryExpression returns Equal
	 *     UnaryExpressionNotPlusMinus returns Equal
	 *     PrimaryExpression returns Equal
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_Equal_1_0_0_4_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, Equal semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getEqualLeftAction_1_0_0_4_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns GreaterThan
	 *     ConditionOrExpression returns GreaterThan
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns GreaterThan
	 *     ConditionAndExpression returns GreaterThan
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns GreaterThan
	 *     RelationOrExpression returns GreaterThan
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns GreaterThan
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns GreaterThan
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns GreaterThan
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns GreaterThan
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns GreaterThan
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns GreaterThan
	 *     AdditionExpression returns GreaterThan
	 *     AdditionExpression.Plus_1_0_0_0_0 returns GreaterThan
	 *     AdditionExpression.Minus_1_0_0_1_0 returns GreaterThan
	 *     MultiplicationExpression returns GreaterThan
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns GreaterThan
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns GreaterThan
	 *     UnaryExpression returns GreaterThan
	 *     UnaryExpressionNotPlusMinus returns GreaterThan
	 *     PrimaryExpression returns GreaterThan
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_GreaterThan_1_0_0_3_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, GreaterThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GREATER_THAN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GREATER_THAN__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GREATER_THAN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GREATER_THAN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getGreaterThanLeftAction_1_0_0_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns GreaterThanOrEqual
	 *     ConditionOrExpression returns GreaterThanOrEqual
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns GreaterThanOrEqual
	 *     ConditionAndExpression returns GreaterThanOrEqual
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns GreaterThanOrEqual
	 *     RelationOrExpression returns GreaterThanOrEqual
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns GreaterThanOrEqual
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns GreaterThanOrEqual
	 *     AdditionExpression returns GreaterThanOrEqual
	 *     AdditionExpression.Plus_1_0_0_0_0 returns GreaterThanOrEqual
	 *     AdditionExpression.Minus_1_0_0_1_0 returns GreaterThanOrEqual
	 *     MultiplicationExpression returns GreaterThanOrEqual
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns GreaterThanOrEqual
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns GreaterThanOrEqual
	 *     UnaryExpression returns GreaterThanOrEqual
	 *     UnaryExpressionNotPlusMinus returns GreaterThanOrEqual
	 *     PrimaryExpression returns GreaterThanOrEqual
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_GreaterThanOrEqual_1_0_0_2_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, GreaterThanOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GREATER_THAN_OR_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GREATER_THAN_OR_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.GREATER_THAN_OR_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.GREATER_THAN_OR_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getGreaterThanOrEqualLeftAction_1_0_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns LessThan
	 *     ConditionOrExpression returns LessThan
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns LessThan
	 *     ConditionAndExpression returns LessThan
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns LessThan
	 *     RelationOrExpression returns LessThan
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns LessThan
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns LessThan
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns LessThan
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns LessThan
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns LessThan
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns LessThan
	 *     AdditionExpression returns LessThan
	 *     AdditionExpression.Plus_1_0_0_0_0 returns LessThan
	 *     AdditionExpression.Minus_1_0_0_1_0 returns LessThan
	 *     MultiplicationExpression returns LessThan
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns LessThan
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns LessThan
	 *     UnaryExpression returns LessThan
	 *     UnaryExpressionNotPlusMinus returns LessThan
	 *     PrimaryExpression returns LessThan
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_LessThan_1_0_0_1_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, LessThan semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.LESS_THAN__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.LESS_THAN__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.LESS_THAN__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.LESS_THAN__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getLessThanLeftAction_1_0_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns LessThanOrEqual
	 *     ConditionOrExpression returns LessThanOrEqual
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns LessThanOrEqual
	 *     ConditionAndExpression returns LessThanOrEqual
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns LessThanOrEqual
	 *     RelationOrExpression returns LessThanOrEqual
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns LessThanOrEqual
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns LessThanOrEqual
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns LessThanOrEqual
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns LessThanOrEqual
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns LessThanOrEqual
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns LessThanOrEqual
	 *     AdditionExpression returns LessThanOrEqual
	 *     AdditionExpression.Plus_1_0_0_0_0 returns LessThanOrEqual
	 *     AdditionExpression.Minus_1_0_0_1_0 returns LessThanOrEqual
	 *     MultiplicationExpression returns LessThanOrEqual
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns LessThanOrEqual
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns LessThanOrEqual
	 *     UnaryExpression returns LessThanOrEqual
	 *     UnaryExpressionNotPlusMinus returns LessThanOrEqual
	 *     PrimaryExpression returns LessThanOrEqual
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_LessThanOrEqual_1_0_0_0_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, LessThanOrEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.LESS_THAN_OR_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.LESS_THAN_OR_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.LESS_THAN_OR_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.LESS_THAN_OR_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getLessThanOrEqualLeftAction_1_0_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NotEqual
	 *     ConditionOrExpression returns NotEqual
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns NotEqual
	 *     ConditionAndExpression returns NotEqual
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns NotEqual
	 *     RelationOrExpression returns NotEqual
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns NotEqual
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns NotEqual
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns NotEqual
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns NotEqual
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns NotEqual
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns NotEqual
	 *     AdditionExpression returns NotEqual
	 *     AdditionExpression.Plus_1_0_0_0_0 returns NotEqual
	 *     AdditionExpression.Minus_1_0_0_1_0 returns NotEqual
	 *     MultiplicationExpression returns NotEqual
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns NotEqual
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns NotEqual
	 *     UnaryExpression returns NotEqual
	 *     UnaryExpressionNotPlusMinus returns NotEqual
	 *     PrimaryExpression returns NotEqual
	 *
	 * Constraint:
	 *     (left=RelationOrExpression_NotEqual_1_0_0_5_0 right=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_RelationOrExpression(ISerializationContext context, NotEqual semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.NOT_EQUAL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.NOT_EQUAL__LEFT));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.NOT_EQUAL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.NOT_EQUAL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getNotEqualLeftAction_1_0_0_5_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationOrExpressionAccess().getRightAdditionExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ReportFunction
	 *     BuiltinFunction returns ReportFunction
	 *     ReportFunction returns ReportFunction
	 *
	 * Constraint:
	 *     instance=[Instance|ID]
	 * </pre>
	 */
	protected void sequence_ReportFunction(ISerializationContext context, ReportFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.REPORT_FUNCTION__INSTANCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.REPORT_FUNCTION__INSTANCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReportFunctionAccess().getInstanceInstanceIDTerminalRuleCall_1_0_1(), semanticObject.eGet(FarmPackage.Literals.REPORT_FUNCTION__INSTANCE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SetFieldValueFunction
	 *     BuiltinFunction returns SetFieldValueFunction
	 *     SetFieldValueFunction returns SetFieldValueFunction
	 *
	 * Constraint:
	 *     (setValueField=[Field|ID] setFieldAttribute=STRING setFieldValue=AdditionExpression)
	 * </pre>
	 */
	protected void sequence_SetFieldValueFunction(ISerializationContext context, SetFieldValueFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_VALUE_FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_VALUE_FIELD));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_FIELD_ATTRIBUTE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_FIELD_ATTRIBUTE));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_FIELD_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_FIELD_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSetFieldValueFunctionAccess().getSetValueFieldFieldIDTerminalRuleCall_0_0_1(), semanticObject.eGet(FarmPackage.Literals.SET_FIELD_VALUE_FUNCTION__SET_VALUE_FIELD, false));
		feeder.accept(grammarAccess.getSetFieldValueFunctionAccess().getSetFieldAttributeSTRINGTerminalRuleCall_2_0(), semanticObject.getSetFieldAttribute());
		feeder.accept(grammarAccess.getSetFieldValueFunctionAccess().getSetFieldValueAdditionExpressionParserRuleCall_4_0(), semanticObject.getSetFieldValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns TrueLiteral
	 *     ConditionOrExpression returns TrueLiteral
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns TrueLiteral
	 *     ConditionAndExpression returns TrueLiteral
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns TrueLiteral
	 *     RelationOrExpression returns TrueLiteral
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns TrueLiteral
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns TrueLiteral
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns TrueLiteral
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns TrueLiteral
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns TrueLiteral
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns TrueLiteral
	 *     AdditionExpression returns TrueLiteral
	 *     AdditionExpression.Plus_1_0_0_0_0 returns TrueLiteral
	 *     AdditionExpression.Minus_1_0_0_1_0 returns TrueLiteral
	 *     MultiplicationExpression returns TrueLiteral
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns TrueLiteral
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns TrueLiteral
	 *     UnaryExpression returns TrueLiteral
	 *     UnaryExpressionNotPlusMinus returns TrueLiteral
	 *     PrimaryExpression returns TrueLiteral
	 *     Literal returns TrueLiteral
	 *     TrueLiteral returns TrueLiteral
	 *
	 * Constraint:
	 *     value='true'
	 * </pre>
	 */
	protected void sequence_TrueLiteral(ISerializationContext context, TrueLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.TRUE_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.TRUE_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrueLiteralAccess().getValueTrueKeyword_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns UnaryExpression
	 *     ConditionOrExpression returns UnaryExpression
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns UnaryExpression
	 *     ConditionAndExpression returns UnaryExpression
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns UnaryExpression
	 *     RelationOrExpression returns UnaryExpression
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns UnaryExpression
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns UnaryExpression
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns UnaryExpression
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns UnaryExpression
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns UnaryExpression
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns UnaryExpression
	 *     AdditionExpression returns UnaryExpression
	 *     AdditionExpression.Plus_1_0_0_0_0 returns UnaryExpression
	 *     AdditionExpression.Minus_1_0_0_1_0 returns UnaryExpression
	 *     MultiplicationExpression returns UnaryExpression
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns UnaryExpression
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns UnaryExpression
	 *     UnaryExpression returns UnaryExpression
	 *     UnaryExpressionNotPlusMinus returns UnaryExpression
	 *     PrimaryExpression returns UnaryExpression
	 *
	 * Constraint:
	 *     exp=UnaryExpression
	 * </pre>
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.UNARY_EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.UNARY_EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getExpUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VarExpression returns VarExpression
	 *     Expression returns VarExpression
	 *     ConditionOrExpression returns VarExpression
	 *     ConditionOrExpression.ConditionOrExpression_1_0_0 returns VarExpression
	 *     ConditionAndExpression returns VarExpression
	 *     ConditionAndExpression.ConditionAndExpression_1_0_0 returns VarExpression
	 *     RelationOrExpression returns VarExpression
	 *     RelationOrExpression.LessThanOrEqual_1_0_0_0_0 returns VarExpression
	 *     RelationOrExpression.LessThan_1_0_0_1_0 returns VarExpression
	 *     RelationOrExpression.GreaterThanOrEqual_1_0_0_2_0 returns VarExpression
	 *     RelationOrExpression.GreaterThan_1_0_0_3_0 returns VarExpression
	 *     RelationOrExpression.Equal_1_0_0_4_0 returns VarExpression
	 *     RelationOrExpression.NotEqual_1_0_0_5_0 returns VarExpression
	 *     AdditionExpression returns VarExpression
	 *     AdditionExpression.Plus_1_0_0_0_0 returns VarExpression
	 *     AdditionExpression.Minus_1_0_0_1_0 returns VarExpression
	 *     MultiplicationExpression returns VarExpression
	 *     MultiplicationExpression.Multiply_1_0_0_0_0 returns VarExpression
	 *     MultiplicationExpression.Divide_1_0_0_1_0 returns VarExpression
	 *     UnaryExpression returns VarExpression
	 *     UnaryExpressionNotPlusMinus returns VarExpression
	 *     PrimaryExpression returns VarExpression
	 *
	 * Constraint:
	 *     var=[Variable|ID]
	 * </pre>
	 */
	protected void sequence_VarExpression(ISerializationContext context, VarExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.VAR_EXPRESSION__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.VAR_EXPRESSION__VAR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarExpressionAccess().getVarVariableIDTerminalRuleCall_0_1(), semanticObject.eGet(FarmPackage.Literals.VAR_EXPRESSION__VAR, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Variable
	 *     Variable returns Variable
	 *     Instance returns Variable
	 *
	 * Constraint:
	 *     (name=ID expression=Expression)
	 * </pre>
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.INSTANCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.INSTANCE__NAME));
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.VARIABLE__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.VARIABLE__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getExpressionExpressionParserRuleCall_3_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns WaitFunction
	 *     BuiltinFunction returns WaitFunction
	 *     WaitFunction returns WaitFunction
	 *
	 * Constraint:
	 *     value=Expression
	 * </pre>
	 */
	protected void sequence_WaitFunction(ISerializationContext context, WaitFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, FarmPackage.Literals.WAIT_FUNCTION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, FarmPackage.Literals.WAIT_FUNCTION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWaitFunctionAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}

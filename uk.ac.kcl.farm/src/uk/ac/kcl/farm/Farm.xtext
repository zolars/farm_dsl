grammar uk.ac.kcl.farm.Farm with org.eclipse.xtext.common.Terminals

generate farm "http://www.ac.uk/kcl/farm/Farm"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

FarmProgram:
	statements += (
		Attribute |
		Crop |
		Field |
		Mission
	)+
;

// General statement

Param:
	"crop" param=ID |
	"field" param=ID |
	"mission" param=ID |
	"real" param=ID |
	"string" param=ID
;

TypeName:
	"null" | "real" | "boolean" | "string"
;

Statement:
	Variable |
	LoopStatement |
	JudgeStatement |
	BuiltinFunction
;

Entity:
	Crop |
	Field |
	Variable
;

//Attribute:
//	entity=[Entity | ID] (
//		".name" | 
//		".stage" |
//		".ip" |
//		".type" |
//		".light" |
//		"." monitor=[Attribute | ID]
//	)?
//;

// Define codes
Attribute:
	"define" name=ID
;

Variable:
	"var" name=ID "=" expression=Expression // | attribute=Attribute
;

LoopStatement:
	"while" "(" condition=Expression ")" "{"
		loopStatements += Statement*
	"}"
;

JudgeStatement:
	"if" "(" condition=Expression ")" "{"
		judgeStatements += Statement*
	"}" 
	elseJudgeStatements += ElseJudgeStatement*
	elseStatements += ElseStatement?
;

ElseJudgeStatement:
	"elseif" "(" condition=Expression ")" "{"
		elseJudgeStatements += Statement*
	"}"
;

ElseStatement:
	{ElseStatement}
	"else" "{" elseStatements += Statement* "}"
;

BuiltinFunction:
	GetValueFunction |
	ReportFunction |
	CountStageFunction |
	SetFieldValueFunction |
	PlantFunction | 
	MoveFunction |
	WaitFunction
;

GetValueFunction:
	entity=[Entity] ".getValue(" attribute=STRING ")"
;


ReportFunction:
	"report(" entity=[Entity | ID] ")"
;

CountStageFunction:
	countStageCrop=[Crop | ID] ".countStage(" ")"
;

SetFieldValueFunction:
	setValueField=[Field | ID] ".setFieldValue(" setFieldAttribute=STRING "," setFieldValue=AdditionExpression ")"
;

PlantFunction:
	plantInField=[Field | ID] ".plant(" plantCrop=[Crop | ID] ")"
;

MoveFunction:
	"move(" moveFromField=[Field | ID] ","  moveToField=[Field | ID] ")"
;

WaitFunction:
	"wait(" value=AdditionExpression ")"
;

//Expressions

Expression:
	ConditionOrExpression
;

ConditionOrExpression returns Expression:
	ConditionAndExpression => (
		{ConditionOrExpression.left=current} "||" right=ConditionAndExpression
	)*
;

ConditionAndExpression returns Expression:
	RelationOrExpression => (
		{ConditionAndExpression.left=current} "&&" right=RelationOrExpression
	)*
;

RelationOrExpression returns Expression:
	AdditionExpression ( => (
		{LessThanOrEqual.left=current} "<=" |
		{LessThan.left=current} "<" |
		{GreaterThanOrEqual.left=current} ">=" |
		{GreaterThan.left=current} ">" |
		{Equal.left=current} "==" |
		{NotEqual.left=current} "!="
	) right=AdditionExpression )* 
;

AdditionExpression returns Expression:
	MultiplicationExpression ( => (
		{Plus.left=current} "+" |
		{Minus.left=current} "-"
	) right+=MultiplicationExpression )*
;

MultiplicationExpression returns Expression:
	UnaryExpression ( => (
		{Multiply.left=current} "*" | 
		{Divide.left=current} "/" 
	) right+=UnaryExpression)*
;

UnaryExpression returns Expression:
	UnaryExpressionNotPlusMinus |
	({UnaryExpression} "-" exp=UnaryExpression) 
;

UnaryExpressionNotPlusMinus returns Expression:
	NotBooleanExpression | PrimaryExpression
;

NotBooleanExpression returns Expression:
	"!" exp=UnaryExpression
;

PrimaryExpression returns Expression:
	Literal |
	var=[Variable] |
	"(" Expression ")"
;

Literal:
	BooleanLiteral | RealLiteral
;

BooleanLiteral:
	{BoolLiteral} val=BOOLEAN
;

terminal BOOLEAN returns ecore::EBoolean:
	"true" | "false"
;

RealLiteral:
	{RealLiteral} val=REAL
;

REAL returns ecore::EFloat hidden():
	INT? "." INT
;

// Crop code block
Crop:
	"crop" name=ID "{"
		"name" ":" cropName=STRING
		"stage" ":" "["
			cropStages += CropStages
		"]"
	"}"
;

CropStages:
	elements += CropStage ("," elements += CropStage)* 
;

CropStage:
	"{"	
		"name" ":" name=STRING
		"timeConsumed" ":" timeConsumend=Expression
		elements += CropAttributes*
	"}"
;

CropAttributes:
	type=[Attribute | ID] ":" value=Expression
;

// Field code block
Field:
	"field" name=ID "{"
		"name" ":" fieldName=STRING
		"ip" ":" ip=IP
		"type" ":" fieldType=("inside" | "outside")
		"light" ":" fieldLight=("sunlight" | "LED")
		"monitor" ":" "[" fieldMonitors+=FieldMonitor ("," fieldMonitors+=FieldMonitor)* "]"
	"}"
;

IP hidden():
	(INT '.' (INT '.' (INT '.' (INT))))
;

FieldMonitor:
	monitor=[Attribute | ID]
;

// Main code block
Mission:
	"mission" name=ID "{"
		missionStatements += (TaskStatement | ExecuteStatement)+
	"}"
;

// Task code block
TaskStatement:
	"task" name=ID "(" (parmas+=Param ("," parmas+=Param)*)? ")" ":" typeName=TypeName "{"
		taskStatements += (Statement | ReturnStatement)*
	"}"
;

ReturnStatement:
	"return" "(" value=Expression ")" 
;

ExecuteStatement:
	{ExecuteStatement} 
	"execute" "{"
		executeStatements += Statement*
	"}"
;
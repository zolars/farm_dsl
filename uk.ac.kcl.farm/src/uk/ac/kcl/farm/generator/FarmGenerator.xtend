/*
 * generated by Xtext 2.18.0.M3
 */
package uk.ac.kcl.farm.generator

import java.util.List
import java.util.Map
import java.util.HashMap

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import uk.ac.kcl.farm.farm.FarmProgram
import uk.ac.kcl.farm.farm.Statement
import uk.ac.kcl.farm.farm.Attribute
import uk.ac.kcl.farm.farm.Crop
import uk.ac.kcl.farm.farm.CropStages
import uk.ac.kcl.farm.farm.CropStage
import uk.ac.kcl.farm.farm.Field
import uk.ac.kcl.farm.farm.CallAttributes
import uk.ac.kcl.farm.farm.Mission
import uk.ac.kcl.farm.farm.Variable
import uk.ac.kcl.farm.farm.VarExpression
import uk.ac.kcl.farm.farm.Assignment
import uk.ac.kcl.farm.farm.LoopStatement
import uk.ac.kcl.farm.farm.JudgeStatement
import uk.ac.kcl.farm.farm.ElseJudgeStatement
import uk.ac.kcl.farm.farm.ElseStatement
import uk.ac.kcl.farm.farm.ReportFunction
import uk.ac.kcl.farm.farm.MoveFunction
import uk.ac.kcl.farm.farm.WaitFunction

import uk.ac.kcl.farm.generator.*
import uk.ac.kcl.farm.interpreter.Exp

//import uk.ac.kcl.farm.farm.Expression
//import uk.ac.kcl.farm.farm.AdditionExpression
//import uk.ac.kcl.farm.farm.MultiplicationExpression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */

class FarmGenerator extends AbstractGenerator {
	
	Runtime runtime = new Runtime()
	Exp expRuntime = new Exp(runtime)
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as FarmProgram
		fsa.generateFile(resource.deriveStatsTargetFileNameFor, model.doGenerateStats)
		
		val className = resource.deriveClassNameFor
		fsa.generateFile(className + '.java', model.doGenerateClass(className))
	}
	
	def deriveStatsTargetFileNameFor(Resource resource) {
		resource.URI.appendFileExtension('txt').lastSegment
	}
	
	def deriveClassNameFor(Resource resource) {
		val origName = resource.URI.lastSegment
		
		origName.substring(0, origName.indexOf('.')).toFirstUpper + 'Farm'
	}
	
	def String doGenerateStats(FarmProgram program) {
		'''
		- «program.eAllContents.filter(Attribute).size» attribute declarations
		«program.statements.filter(Attribute).map[generateTimetable(new Environment)].join('\n')»
		- «runtime.attributeList.size» attribute processed
		
		- «program.eAllContents.filter(Crop).size» crop declarations
		«program.statements.filter(Crop).map[generateTimetable(new Environment)].join('\n')»
		- «runtime.cropMap.size» crop processed
		
		- «program.eAllContents.filter(Field).size» field declarations
		«program.statements.filter(Field).map[generateTimetable(new Environment)].join('\n')»
		- «runtime.fieldMap.size» field processed
		
		«program.statements.filter(Mission).map[generateTimetable(new Environment)].join('\n')»
		'''
	}
	
	def String doGenerateClass(FarmProgram program, String className) '''
		import uk.ac.kcl.farm.library.*
		
		public class «className» {

			public static void main (String[] args) {
				FarmFrame tf = new FarmFrame();
				
				Farm t = new Farm(tf) {
					@Override
					protected void run() {
						«program.statements.map[generateJavaStatement(new Environment)].join('\n')»
					}
				};
				
				t.run();
			}
		}
//	'''
	
	private static class Environment {
		var int counter = 0
		
		def getFreshVarName() '''i«counter++»'''
		
		def exit() { counter-- }
	}
	
	/*
	 * generateTimetable
	 */
	 
 	dispatch def String generateTimetable(Attribute attribute, Environment env) {
 		runtime.attributeList.add(attribute.name)
 		
		'''    - Attribute `«attribute.name»` processed'''
	}
	
	dispatch def String generateTimetable(Crop crop, Environment env) {
		var List<GeneratedStage> generatedStages = newArrayList()
		for (CropStages stages : crop.cropStages) {
			for (CropStage stage : stages.elements) {
				var attributes = new HashMap<String, Float>
				for (CallAttributes attribute : stage.attributes) {
					if (runtime.attributeList.contains(attribute.type.name)) {
						attributes.put(attribute.type.name, expRuntime.toFloat(attribute.value))
					} else {
						throw new Exception('''
							Undefined attribute «attribute.type.name» used in Crop: «crop.name»
							Avaible attributes is as below: «runtime.attributeList»
						''');
					}
				}
				
				var time = expRuntime.toFloat(stage.time)
				var timeover = expRuntime.toFloat(stage.timeover)
				if (time >= 0) {
					var newStage = new GeneratedStage(stage.name, time, timeover, attributes)
					generatedStages.add(newStage)
				} else {					
					throw new Exception('''
						At Crop `«crop.name»`, `timeConsumed` must be a Float bigger than 0
					''');
				}
			}	
		}
		
		var newCrop = new GeneratedCrop(crop.cropName, generatedStages)
		runtime.cropMap.put(crop.name, newCrop)
	
		'''    - Crop `«crop.name»` processed'''
	}

 	dispatch def String generateTimetable(Field field, Environment env) {
 		var attributes = new HashMap<String, Float>
 		
 		for (CallAttributes attribute : field.attributes) { 
 			if (runtime.attributeList.contains(attribute.type.name)) {
 				attributes.put(attribute.type.name, expRuntime.toFloat(attribute.value))
 			} else {
				throw new Exception('''
					Undefined attribute «attribute.type.name» used in Field: «field.name»
					Avaible attributes is as below: «runtime.attributeList»
				''');
			}
 		}
 		
 		var newField = new GeneratedField(field.fieldName, field.fieldIP, field.fieldType, field.fieldLight, attributes)
		runtime.fieldMap.put(field.name, newField)
		
 		'''    - Field `«field.name»` processed'''
	}
	
	dispatch def String generateTimetable(Mission mission, Environment env) {
		'''«mission.missionStatements.map[generateTimetable(new Environment)].join('')»'''
	}
	
	dispatch def String generateTimetable(Variable variable, Environment env) {
		var exp = variable.expression
		try {
			runtime.variableMap.put(variable.name, expRuntime.toFloat(exp))
		} catch (Exception e1) {
			try {
				runtime.variableMap.put(variable.name, expRuntime.toBoolean(exp))
			} catch (Exception e2) {
				throw e2
			}
		}
		println('''- Variable `«variable.name» : «runtime.variableMap.get(variable.name)»` processed''')
		''''''
	}
	
	dispatch def String generateTimetable(Assignment assignment, Environment env) {
		var exp = assignment.expression
		try {
			runtime.variableMap.put(assignment.^var.name, expRuntime.toFloat(exp))
		} catch (Exception e1) {
			try {
				runtime.variableMap.put(assignment.^var.name, expRuntime.toBoolean(exp))
			} catch (Exception e2) {
				throw e2
			}
		}
		println('''- Assignment `«assignment.^var.name» : «runtime.variableMap.get(assignment.^var.name)»` processed''')
		''''''
	}
	
	dispatch def String generateTimetable(LoopStatement loop, Environment env) {
		var result = ""
		while (expRuntime.toBoolean(loop.condition)) {
			result += loop.loopStatements.map[generateTimetable(new Environment)].join('')
		}
		result
	}
	
	dispatch def String generateTimetable(JudgeStatement judge, Environment env) {
		var result = ""
		if (expRuntime.toBoolean(judge.condition)) {
			result += judge.judgeStatements.map[generateTimetable(new Environment)].join('')
		} else {
			var successKey = false
			for (ElseJudgeStatement elseJudgeStatement : judge.elseJudgeStatements) {
				 if (expRuntime.toBoolean(elseJudgeStatement.condition) && !successKey) {
				 	successKey = true
				 	result += elseJudgeStatement.elseJudgeStatements.map[generateTimetable(new Environment)].join('')
				 }
			}
			if (!successKey) {
				for (ElseStatement elseStatement : judge.elseStatement) {
					result += elseStatement.elseStatements.map[generateTimetable(new Environment)].join('')
				}
			}
		}
		result
	}
	
	dispatch def String generateTimetable(ReportFunction function, Environment env) {
		println(function.instance.toString)
		''''''
	}
	
	dispatch def String generateTimetable(MoveFunction function, Environment env) {
		var moveFromField = runtime.fieldMap.get(function.moveFromField.name)
		var moveToField = runtime.fieldMap.get(function.moveToField.name)
		
		
		if (moveFromField.crop === null) {
			throw new Exception('''Field `«moveFromField.name»` is empty''')
		} else if (moveToField.crop !== null) {
			throw new Exception('''Field `«moveToField.name»` is not empty''')
		} else if (expRuntime.judegeEnvironment(moveToField, moveFromField.crop.currentStage)) {
			moveToField.crop = moveFromField.crop
			moveFromField.crop = null
			moveToField.crop.field = moveToField
		}
		
		''''''
	}
	
	dispatch def String generateTimetable(WaitFunction function, Environment env) {
		var result = ""
		
		runtime.time += expRuntime.toFloat(function.value)
		
		
		for (e : runtime.cropMap.entrySet) {
			var crop = e.value
			if (crop.field !== null) {
				crop.time += expRuntime.toFloat(function.value)
				
				var float timeNeeded = 0
				
				for (i : 0..crop.currentStageID) {
					timeNeeded += crop.stage.get(i).time
					
				}
				
				var float timeOverflow = timeNeeded + crop.currentStage.timeover
				
				var float timeExised = expRuntime.toFloat(function.value) + crop.time
				
				if (timeExised < timeNeeded) {
					
					result += '''
Crop `«crop.name»` is growing in Field `«crop.field.name»`.
	Stage is still in `«crop.currentStage.name»`.
	Need «timeNeeded - timeExised» days to step into the next stage.
					'''
					
				} else if (timeExised >= timeNeeded && timeExised < timeOverflow) {
					
					crop.currentStageID += 1
					crop.currentStage = crop.stage.get(crop.currentStageID)
					result += '''
Crop `«crop.name»` is growing in Field `«crop.field.name»`.
	Stage is changed to `«crop.currentStage.name»`.
	You need to handle the crop in «timeOverflow - timeExised» days otherwise it will die.
					'''
		
				} else if (timeExised >= timeOverflow) {
					throw new Exception('''Crop `«crop.name»` is died because time exceeded''')
				}
			}
		}
		
		result
	}
	
	dispatch def String generateTimetable(Statement stmt, Environment env) ''''''
	
	/*
	 * generateJavaStatement
	 */
	 
	dispatch def String generateJavaStatement(Attribute attribute, Environment env) '''
	«attribute.name»
	'''
	
	dispatch def String generateJavaStatement(ReportFunction func, Environment env) {
	''''''
	}
	
	dispatch def String generateJavaStatement(Crop stmt, Environment env) ''''''
	dispatch def String generateJavaStatement(Field stmt, Environment env) ''''''
	dispatch def String generateJavaStatement(Mission stmt, Environment env) ''''''
	dispatch def String generateJavaStatement(Statement stmt, Environment env) ''''''
	
}
